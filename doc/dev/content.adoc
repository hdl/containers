include::contributing.adoc[]

== Continuous Integration (CI)

[cols="6*.^", frame=none, grid=none]
|===
a|* {blank}
+
--
GHAStatus:doc[]
--

* {blank}
+
--
GHAStatus:base[]
--


a|* {blank}
+
--
GHAStatus:ghdl[]
--
* {blank}
+
--
GHAStatus:gtkwave[]
--
* {blank}
+
--
GHAStatus:verilator[]
--
* {blank}
+
--
GHAStatus:xyce[]
--


a|* {blank}
+
--
GHAStatus:apicula[]
--
* {blank}
+
--
GHAStatus:ghdl-yosys-plugin[]
--
* {blank}
+
--
GHAStatus:icestorm[]
--
* {blank}
+
--
GHAStatus:prjtrellis[]
--
* {blank}
+
--
GHAStatus:yosys[]
--
* {blank}
+
--
GHAStatus:nextpnr[]
--
* {blank}
+
--
GHAStatus:arachne-pnr[]
--
* {blank}
+
--
GHAStatus:openfpgaloader[]
--


a|* {blank}
+
--
GHAStatus:boolector[]
--
* {blank}
+
--
GHAStatus:cvc[]
--
* {blank}
+
--
GHAStatus:pono[]
--
* {blank}
+
--
GHAStatus:superprove[]
--
* {blank}
+
--
GHAStatus:symbiyosys[]
--
* {blank}
+
--
GHAStatus:yices2[]
--
* {blank}
+
--
GHAStatus:z3[]
--


a|* {blank}
+
--
GHAStatus:klayout[]
--
* {blank}
+
--
GHAStatus:magic[]
--


a|* {blank}
+
--
GHAStatus:formal[]
--
* {blank}
+
--
GHAStatus:sim[]
--
* {blank}
+
--
GHAStatus:impl[]
--
* {blank}
+
--
GHAStatus:prog[]
--
|===

NOTE: At the moment, there is no triggering mechanism set up between different GitHub repositories.
All the workflows in this repo are triggered by push events, CRON jobs, or manually.

== Tasks

The strategical priorities are the following:

* Add the missing ASIC tools to collection `debian/buster`.
Following the order in https://github.com/efabless/openlane#openlane-design-stages[efabless/openlane: OpenLANE Design Stages]
is suggested.

* Add the missing tools to collection `centos/7`.
This collection is currently empty (it contains the base dockerfile only).
It was added because OpenLane containers are based on `centos:7``, but may be updated to `centos:8`.
Moreover, some DARPA users might be constrained to `centos:6`.
We should confirm that.

* Setup cross-triggering between CI workflows.
Currently, all workflows are triggered at the same time.
That produces some races and some tools are built twice in the same run (https://github.com/moby/buildkit/issues/1930[moby/buildkit#1930]).
That is not critical because we do know how to solve it (link:{repotree}.github/trigger.sh[`.github/trigger.sh`]).
We didn't implement it yet because we'd like it to be automatically sychronised with the graphs (see <<Graph generation/parsing>>).

* Coordinate with Antmicro/SymbiFlow for using self-hosted runners provided by Google and their orchestration plumbing.

* Enhance the (atomic) https://github.com/hdl/smoke-tests[smoke-tests], which are currently placeholders mostly.

* Provide multiarch images (at least, add arm32v7 and arm64v8 variants).
See https://github.com/dbhi/qus[dbhi/qus] and https://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/[Multi-arch build and images, the simple way].

* Versioning.
Currently, images are not versioned explicitly.
Images are only pushed when builds and tests are successful.
Users which cannot afford breaking changes can use the image by digest, instead of doing it by name.
However, we should probably leverage manifests for publishing some _versioned ecosystems_, impliying that we run a full
test suite on an specific group of images and we then tag them all together as a _nicely behaving family/release_.

NOTE: These are all in no particular order, although most of them are closely related to each other.
It you want to tackle any of them, https://github.com/hdl/containers/issues/new[let us know] or
https://gitter.im/hdl/community[join the chat]!

== Graph generation/parsing

Currently, the <<Graphs>> are updated manually.
That is error prone, because the information shown in them is also defined in the dockerfiles and CI workflows.
Ideally, graphs would be auto-generated by parsing/analysing those.
However, the complexity of the graphs is non trivial.
There are many tools for automatically generating diagrams from large datasets, but not so many with features for
visualizing complex hierarchical nets.
The requirements we are willing to satisfy are the following:

* Open source tool and format(s).
* Generates diagrams programmatically from a text representation and/or through a Python or Golang API.
* Supports hierarchical DAGs with multiple levels of hierarchy. I.e. (nested) clusters which are nodes and have ports.
* Generates SVG of the hierarchical DAGs.
* Supports node styles (shape and colour).
* Ideally:
** Clusters are collapsible when shown in an HTML site.
** Text in the nodes can be links to web sites.

So far, the following options were analysed:

* https://graphviz.org/[Graphviz]
** https://github.com/windler/dotgraph[windler/dotgraph]
** http://blockdiag.com/en/blockdiag/examples.html[blockdiag]
* https://gephi.org/[Gephi]
** https://github.com/gephi/gephi/issues/1594[gephi/gephi#1594]
* https://aafigure.readthedocs.io/en/latest/shortintro.html[aafigure]
* https://draw.io[draw.io]
** https://github.com/jgraph/mxgraph[jgraph/mxgraph]
* https://www.yworks.com/products/yed[yEd]
* https://texample.net/tikz/[texample.net/tikz]
* https://github.com/ajstarks/svgo[ajstarks/svgo]
* https://github.com/kieler/elkjs[kieler/elkjs] (https://github.com/Nic30/d3-hwschematic[Nic30/d3-hwschematic], https://github.com/nturley/netlistsvg[nturley/netlistsvg])
* https://github.com/dagrejs/dagre-d3/wiki[dagrejs/dagre-d3]
* https://graphdracula.net[graphdracula.net]

Graphviz and Gephi are probably the most known tools for generating all kinds of diagrams.
Unfortunately, none of them supports hierarchical clusters as required in this use case.
The same issue applies to aafigure and graphdracula.

yEd is a very interesting product, and fits most (if not all) the technical constraints.
However, it's not open source.
The editor is freeware and the SDK is paid.
For programmatic generation, the SDK is required.
The draw.io/mxgraph toolkit seems to be the most similar open source solution.
However, using SDKs for building custom interactive diagraming tools feels overkill in this use case.
We don't need graphs to be editable through a GUI!

Similarly, Tikz and SVG generation libraries (such as svgo) can be used for having the work done, but they require
writing a non-negligible plumbing which would increase the maintenance burden, instead of reducing it.
This would be a last resort.

Although d3-hwschematic and netlistsvg are very different use cases, the JSON format used in elkjs might be suitable.

dagre-d3 is meant for DAGs and it supports nested clusters (experimentally,
https://dagrejs.github.io/project/dagre-d3/latest/demo/clusters.html[Dagre D3 Demo: Clusters]).
Although clusters seem not to have ports, it might be an easy update from the current solution.
Since it's a client-side JS library, it does not write an SVG file to disk by default, but achieving it should be
trivial.

As a result, it seems that the most suitable solution might be using the JSON format from elkjs, either with elkjs or
with dagre-d3.
Yet, generating an SVG programmatically seems not to be as straightforward as using other solutions such as Graphviz's
`dot`.
The following references illustrate advanced features for building custom views/GUIs/editors:

* https://github.com/kieler/elkjs[kieler/elkjs]
* https://www.eclipse.org/elk/documentation/tooldevelopers/graphdatastructure/jsonformat.html[eclipse.org/elk/documentation: JSON format]
* https://rtsys.informatik.uni-kiel.de/elklive/index.html[rtsys.informatik.uni-kiel.de/elklive]
* https://rtsys.informatik.uni-kiel.de/elklive/elkgraph.html[rtsys.informatik.uni-kiel.de/elklive/elkgraph]
* https://github.com/eclipse/sprotty[eclipse/sprotty]

However, it seems that writing a JSON is cumbersome.
On the one hand, some nodes need to have a size for them to be shown.
On the other hand, it seems not possible to draw edges across hierarchies.
Port need to be explicitly defined for that purpose.
Therefore, the complexity of generating the JSON given a set of nodes, edges and clusters is non-trivial.

[NOTE]
====
Branch https://github.com/hdl/containers/tree/pymap/utils/pyHDLC/map.py[utils/pyHDLC/map.py@pymap] contains work in progress.
First, `GenerateMap` builds a DAG by parsing the dockerfiles.
Then, `report` prints the content in the terminal, for debugging purposes.
Last, `dotgraph` generates a Graphviz dot diagram.
The dot diagram does not have clusters.
We want to add those by parsing the GitHub Actions workflows (see below).
However, we want to first reproduce the dot output using elkjs.
See function `elkjsgraph` in https://github.com/hdl/containers/tree/pymap/utils/pyHDLC/map.py[utils/pyHDLC/map.py@pymap].
Do you want to give it a try? https://github.com/hdl/containers/issues/new[Let us know] or https://gitter.im/hdl/community[join the chat]!
====

=== Reading dockerfiles

One of the two sources of information for the graph are dockerfiles.
As far as we are aware, there is no tool for generating a DAG from the stages of a dockerfile.
However, https://github.com/asottile/dockerfile[asottile/dockerfile] is an interesting Python module which wraps
docker/moby's golang parser.
Hence, it can be used for getting the stages and `COPY --from` or `--mount` statements for generating the hierarchy.
See link:{repotree}utils/pyHDLC/map.py[`utils/pyHDLC/map.py`].

=== Reading GitHub Actions workflow files

The second source of information are CI workflow files.
Since YAML is used, reading it from any language is trivial, however, semantic analysis needs to be done.
Particularly, variables from `matrix` need to be expanded/replaced.
https://github.com/nektos/act[nektos/act] is written in golang, and it allows executing GitHub Actions workflows
locally.
Therefore, it might have the required features.
However, as far as we are aware, it's not meant to be used as a library.
